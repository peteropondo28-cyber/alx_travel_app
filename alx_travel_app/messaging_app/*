# messaging_app — Complete Project Code

Below are the complete files for the `messaging_app` Django project implementing the tasks you requested: project setup, models, serializers, viewsets, URL routing, admin registration, and a minimal settings file to get started.

Paste these files into your `alx-backend-python/messaging_app` repository following the path shown for each file.

---

## File tree

```
messaging_app/
├── manage.py
├── requirements.txt
├── .env.example
├── messaging_app/
│   ├── __init__.py
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── chats/
    ├── __init__.py
    ├── admin.py
    ├── apps.py
    ├── migrations/
    │   └── __init__.py
    ├── models.py
    ├── serializers.py
    ├── views.py
    ├── urls.py
    └── tests.py
```

---

## `requirements.txt`

```text
Django>=4.2
djangorestframework>=3.14
django-environ>=0.11
psycopg2-binary>=2.9  # optional if you plan PostgreSQL, not required for sqlite
python-dotenv>=1.0.0
```

---

## `.env.example`

```text
# Copy to .env and edit
DEBUG=True
SECRET_KEY=changeme-please-generate-a-secure-key
ALLOWED_HOSTS=127.0.0.1,localhost
DATABASE_URL=sqlite:///db.sqlite3
```

---

## `manage.py`

```python
#!/usr/bin/env python
import os
import sys

if __name__ == '__main__':
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'messaging_app.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and available on your PYTHONPATH?"
        ) from exc
    execute_from_command_line(sys.argv)
```

---

## `messaging_app/__init__.py`

```python
# empty
```

---

## `messaging_app/asgi.py`

```python
import os
from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'messaging_app.settings')
application = get_asgi_application()
```

---

## `messaging_app/wsgi.py`

```python
import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'messaging_app.settings')
application = get_wsgi_application()
```

---

## `messaging_app/settings.py`

```python
"""
Minimal settings to run the messaging_app for development.
"""
import os
from pathlib import Path
import environ

BASE_DIR = Path(__file__).resolve().parent.parent

# Load .env if present
env = environ.Env(DEBUG=(bool, False))
env_file = BASE_DIR / '.env'
if env_file.exists():
    environ.Env.read_env(env_file)

SECRET_KEY = env('SECRET_KEY', default='dev-secret-key-change-me')
DEBUG = env('DEBUG', default=True)
ALLOWED_HOSTS = env('ALLOWED_HOSTS', default='127.0.0.1,localhost').split(',')

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    # third-party
    'rest_framework',

    # local apps
    'chats',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'messaging_app.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'messaging_app.wsgi.application'

# Database
# Keep simple: sqlite by default, change DATABASE_URL in .env for production
DATABASE_URL = env('DATABASE_URL', default=f"sqlite:///{BASE_DIR / 'db.sqlite3'}")

import dj_database_url
DATABASES = {
    'default': dj_database_url.parse(DATABASE_URL)
}

# Password validation (keep defaults for development)
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_L10N = True
USE_TZ = True

STATIC_URL = '/static/'
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Custom user model
AUTH_USER_MODEL = 'chats.User'

# Django REST framework basic config
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticatedOrReadOnly',
    ),
}
```

---

## `messaging_app/urls.py`

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('chats.urls')),
]
```

---

## `chats/__init__.py`

```python
# empty
```

---

## `chats/apps.py`

```python
from django.apps import AppConfig


class ChatsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'chats'
```

---

## `chats/migrations/__init__.py`

```python
# empty
```

---

## `chats/models.py`

```python
import uuid
from django.db import models
from django.contrib.auth.models import AbstractUser

class User(AbstractUser):
    """
    Custom User model extending AbstractUser.
    Uses a UUID primary key `user_id` per project spec.
    """
    user_id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False, db_index=True)

    # Make email unique per spec. We still keep 'username' to remain compatible with Django admin.
    email = models.EmailField(unique=True)
    phone_number = models.CharField(max_length=32, blank=True, null=True)

    ROLE_GUEST = 'guest'
    ROLE_HOST = 'host'
    ROLE_ADMIN = 'admin'
    ROLE_CHOICES = [
        (ROLE_GUEST, 'Guest'),
        (ROLE_HOST, 'Host'),
        (ROLE_ADMIN, 'Admin'),
    ]
    role = models.CharField(max_length=10, choices=ROLE_CHOICES, default=ROLE_GUEST)

    created_at = models.DateTimeField(auto_now_add=True)

    # Keep username as the USERNAME_FIELD to avoid needing a custom manager for email-login.
    USERNAME_FIELD = 'username'
    REQUIRED_FIELDS = ['email']

    def __str__(self):
        return f"{self.username} ({self.email})"


class Conversation(models.Model):
    """Conversation model tracking participants."""
    conversation_id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False, db_index=True)
    participants = models.ManyToManyField('User', related_name='conversations')
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Conversation {self.conversation_id} (participants={self.participants.count()})"


class Message(models.Model):
    """Message model belonging to a conversation and sent by a user."""
    message_id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False, db_index=True)
    sender = models.ForeignKey('User', on_delete=models.CASCADE, related_name='sent_messages')
    conversation = models.ForeignKey('Conversation', on_delete=models.CASCADE, related_name='messages')
    message_body = models.TextField()
    sent_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Message {self.message_id} from {self.sender_id} at {self.sent_at}"
```

---

## `chats/serializers.py`

```python
from rest_framework import serializers
from .models import User, Conversation, Message


class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ('user_id', 'username', 'first_name', 'last_name', 'email', 'phone_number', 'role', 'created_at')
        read_only_fields = ('user_id', 'created_at')


class MessageSerializer(serializers.ModelSerializer):
    sender = UserSerializer(read_only=True)
    sender_id = serializers.UUIDField(write_only=True, required=False)

    class Meta:
        model = Message
        fields = ('message_id', 'sender', 'sender_id', 'conversation', 'message_body', 'sent_at')
        read_only_fields = ('message_id', 'sent_at', 'sender')

    def create(self, validated_data):
        sender_id = validated_data.pop('sender_id', None)
        if not sender_id:
            raise serializers.ValidationError({'sender_id': 'sender_id is required unless request.user is used.'})

        # Resolve sender
        try:
            sender = User.objects.get(user_id=sender_id)
        except User.DoesNotExist:
            raise serializers.ValidationError({'sender_id': 'User with this id does not exist.'})

        message = Message.objects.create(sender=sender, **validated_data)
        return message


class ConversationSerializer(serializers.ModelSerializer):
    participants = UserSerializer(many=True, read_only=True)
    participants_ids = serializers.ListField(
        child=serializers.UUIDField(), write_only=True, required=True,
        help_text='List of user_id UUIDs to include in the conversation'
    )
    messages = MessageSerializer(many=True, read_only=True)

    class Meta:
        model = Conversation
        fields = ('conversation_id', 'participants', 'participants_ids', 'created_at', 'messages')
        read_only_fields = ('conversation_id', 'created_at', 'participants', 'messages')

    def create(self, validated_data):
        participant_ids = validated_data.pop('participants_ids', [])
        conv = Conversation.objects.create()
        users = User.objects.filter(user_id__in=participant_ids)
        if users.count() != len(participant_ids):
            found = {str(u.user_id) for u in users}
            missing = [str(p) for p in participant_ids if str(p) not in found]
            raise serializers.ValidationError({'participants_ids': f'Some users not found: {missing}'})
        conv.participants.set(users)
        return conv
```

---

## `chats/views.py`

```python
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.decorators import action
from .models import Conversation, Message, User
from .serializers import ConversationSerializer, MessageSerializer, UserSerializer
from rest_framework.permissions import IsAuthenticatedOrReadOnly


class ConversationViewSet(viewsets.ModelViewSet):
    """ViewSet for conversations: list, retrieve, create, update, destroy."""
    queryset = Conversation.objects.all().prefetch_related('participants', 'messages')
    serializer_class = ConversationSerializer
    permission_classes = [IsAuthenticatedOrReadOnly]

    @action(detail=False, methods=['get'], url_path='mine')
    def my_conversations(self, request):
        if not request.user.is_authenticated:
            return Response([], status=status.HTTP_200_OK)
        qs = self.queryset.filter(participants=request.user)
        serializer = self.get_serializer(qs, many=True)
        return Response(serializer.data)


class MessageViewSet(viewsets.ModelViewSet):
    """ViewSet for messages: list, retrieve, create, etc."""
    queryset = Message.objects.all().select_related('sender', 'conversation').order_by('sent_at')
    serializer_class = MessageSerializer
    permission_classes = [IsAuthenticatedOrReadOnly]

    def create(self, request, *args, **kwargs):
        data = request.data.copy()

        # If authenticated, prefer to use request.user as sender
        if request.user.is_authenticated and hasattr(request.user, 'user_id'):
            data['sender_id'] = str(request.user.user_id)

        serializer = self.get_serializer(data=data)
        serializer.is_valid(raise_exception=True)

        # Ensure conversation exists
        conv = serializer.validated_data.get('conversation')
        if not conv:
            return Response({'conversation': 'A valid conversation id is required.'}, status=status.HTTP_400_BAD_REQUEST)

        # Optional: ensure sender is participant of conversation
        sender_id = serializer.validated_data.get('sender')

        # perform_save
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)
```

---

## `chats/urls.py`

```python
from rest_framework.routers import DefaultRouter
from django.urls import path, include
from .views import ConversationViewSet, MessageViewSet

router = DefaultRouter()
router.register(r'conversations', ConversationViewSet, basename='conversation')
router.register(r'messages', MessageViewSet, basename='message')

urlpatterns = [
    path('', include(router.urls)),
]
```

---

## `chats/admin.py`

```python
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from .models import User, Conversation, Message


@admin.register(User)
class UserAdmin(BaseUserAdmin):
    fieldsets = BaseUserAdmin.fieldsets + (
        ('Additional', {'fields': ('user_id', 'phone_number', 'role', 'created_at')}),
    )
    readonly_fields = ('user_id', 'created_at')


@admin.register(Conversation)
class ConversationAdmin(admin.ModelAdmin):
    list_display = ('conversation_id', 'created_at')
    readonly_fields = ('conversation_id', 'created_at')
    filter_horizontal = ('participants',)


@admin.register(Message)
class MessageAdmin(admin.ModelAdmin):
    list_display = ('message_id', 'sender', 'conversation', 'sent_at')
    readonly_fields = ('message_id', 'sent_at')
```

---

## `chats/tests.py`

```python
from django.test import TestCase
from django.urls import reverse
from rest_framework.test import APIClient
from .models import User, Conversation, Message
import uuid


class ChatsAPITestCase(TestCase):
    def setUp(self):
        self.client = APIClient()
        self.user1 = User.objects.create_user(username='user1', email='u1@example.com', password='pass')
        self.user2 = User.objects.create_user(username='user2', email='u2@example.com', password='pass')

    def test_create_conversation(self):
        url = reverse('conversation-list')
        payload = {'participants_ids': [str(self.user1.user_id), str(self.user2.user_id)]}
        resp = self.client.post(url, payload, format='json')
        self.assertEqual(resp.status_code, 201)
        self.assertIn('conversation_id', resp.data)

    def test_create_message(self):
        conv = Conversation.objects.create()
        conv.participants.set([self.user1, self.user2])
        url = reverse('message-list')
        payload = {
            'sender_id': str(self.user1.user_id),
            'conversation': str(conv.conversation_id),
            'message_body': 'Hello'
        }
        resp = self.client.post(url, payload, format='json')
        self.assertEqual(resp.status_code, 201)
        self.assertIn('message_id', resp.data)
```

---

### How to run

1. Create a virtual environment and install dependencies:

```bash
python -m venv .venv
source .venv/bin/activate  # Windows: .venv\Scripts\activate
pip install -r requirements.txt
```

2. Create a `.env` from `.env.example` and adjust settings if desired.

3. Make migrations and migrate:

```bash
python manage.py makemigrations
python manage.py migrate
```

4. Create a superuser and runserver:

```bash
python manage.py createsuperuser
python manage.py runserver
```

5. API endpoints are available at:

* `GET/POST /api/conversations/`
* `GET/POST /api/messages/`
* `GET /api/conversations/mine/` (authenticated user's conversations)

---

If you'd like, I can generate these files in a downloadable zip or prepare a commit-ready patch. Tell me which you prefer.
